<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>Webãƒ–ãƒ©ã‚¦ã‚¶ 3Dãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã‚µã‚¤ãƒˆ (ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ç·¨é›†ç‰ˆ)</title>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        .dg.main { z-index: 100 !important; }

        #model-add-buttons {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            width: 245px; background-color: #1a1a1a; font-family: monospace; font-size: 11px;
        }
        #model-add-buttons h3 { margin: 0; padding: 4px 5px; color: #fff; background-color: #000; }
        #model-add-buttons button {
            display: block; width: 98%; padding: 4px 0; margin: 1px auto; cursor: pointer;
            background-color: #333; color: #fff; border: 1px solid #333; font-size: 11px;
        }
        #model-add-buttons button:hover { background-color: #444; }

        #exportModal {
            display:none; position:fixed; top:0; left:0; width:100%; height:100%; 
            background:rgba(0,0,0,0.5); z-index:200; font-family: sans-serif;
        }
        .modal-content { background:#fff; width:300px; margin:100px auto; padding:20px; border-radius:5px; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/OBJExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
</head>
<body>
    <div id="model-add-buttons">
        <h3>ğŸ“ ãƒ¢ãƒ‡ãƒ«ã®è¿½åŠ </h3>
        <button onclick="addBox()">ç«‹æ–¹ä½“ã‚’è¿½åŠ </button>
        <button onclick="addSphere()">çƒä½“ã‚’è¿½åŠ </button>
        <button onclick="addCylinder()">å††æŸ±ã‚’è¿½åŠ </button> 
        <button onclick="addPlane()">å¹³é¢ã‚’è¿½åŠ </button> 
    </div>
    
    <input type="file" id="fileInput" style="display: none;">

    <div id="exportModal">
        <div class="modal-content">
            <h3>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆè¨­å®š</h3>
            <select id="exportFormatSelect" style="width:100%; margin-bottom:15px; padding:5px;">
                <option value="json">JSON (ç·¨é›†ç”¨)</option>
                <option value="obj">OBJ (3Dã‚½ãƒ•ãƒˆç”¨)</option>
                <option value="glb">GLB (æ±ç”¨å½¢å¼)</option>
            </select>
            <button id="confirmExportButton" style="background:#007bff; color:white; border:none; padding:8px 15px; cursor:pointer;">ä¿å­˜ã‚’å®Ÿè¡Œ</button>
            <button onclick="document.getElementById('exportModal').style.display='none'" style="padding:8px 15px; cursor:pointer;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        </div>
    </div>

    <script>
        // --- åŸºæœ¬è¨­å®š ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0); 
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const vertexMarkersGroup = new THREE.Group();
        const faceMarkersGroup = new THREE.Group();
        scene.add(vertexMarkersGroup, faceMarkersGroup);

        let isVertexMode = false, isFaceMode = false;
        let currentEditableMesh = null, selectedFaceIndex = -1;
        const highlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.5, transparent: true, side: THREE.DoubleSide });
        let faceHighlighter = null;

        const history = { stack: [], index: -1, limit: 30 };
        function saveState() {
            const meshes = [];
            scene.traverse(obj => {
                if (obj.isMesh && !obj.userData.isMarker && obj.name !== "Highlighter" && obj.type !== "GridHelper") {
                    meshes.push({
                        name: obj.name, position: obj.position.toArray(), rotation: obj.rotation.toArray(), scale: obj.scale.toArray(),
                        color: '#' + obj.material.color.getHexString(),
                        vertices: Array.from(obj.geometry.attributes.position.array)
                    });
                }
            });
            const state = JSON.stringify(meshes);
            if (history.index < history.stack.length - 1) history.stack = history.stack.slice(0, history.index + 1);
            history.stack.push(state);
            if (history.stack.length > history.limit) history.stack.shift(); else history.index++;
        }
        function undo() { if (history.index > 0) applyState(history.stack[--history.index]); }

        function applyState(stateData) {
            const data = JSON.parse(stateData);
            scene.children.filter(obj => obj.isMesh && !obj.userData.isMarker && obj.name !== "Highlighter" && obj.type !== "GridHelper").forEach(obj => {
                scene.remove(obj); obj.geometry.dispose(); obj.material.dispose();
            });
            data.forEach(d => {
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(d.vertices), 3));
                geo.computeVertexNormals();
                const mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: d.color }));
                mesh.position.fromArray(d.position); mesh.rotation.fromArray(d.rotation); mesh.scale.fromArray(d.scale);
                scene.add(mesh);
            });
            transformControls.detach();
            updateGuiFromSelection();
        }

        // --- GUI & ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£åˆ¶å¾¡ ---
        const gui = new dat.GUI();
        const guiParams = {
            vertexMode: false, faceMode: false,
            extrude: () => extrudeFace(),
            undo: () => undo(),
            export: () => document.getElementById('exportModal').style.display='block',
            import: () => document.getElementById('fileInput').click(),
            // é¸æŠä¸­ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
            color: '#0077ff',
            scaleX: 1, scaleY: 1, scaleZ: 1
        };

        gui.add(guiParams, 'vertexMode').name('é ‚ç‚¹ç·¨é›† (V)').onChange(toggleVertexEditMode).listen();
        gui.add(guiParams, 'faceMode').name('é¢ç·¨é›† (F)').onChange(toggleFaceEditMode).listen();
        gui.add(guiParams, 'extrude').name('é¢ã‚’æŠ¼ã—å‡ºã—');
        gui.add(guiParams, 'undo').name('å…ƒã«æˆ»ã™ (Ctrl+Z)');

        const propFolder = gui.addFolder('ğŸ¨ é¸æŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£');
        const colorCtrl = propFolder.addColor(guiParams, 'color').name('è‰²').onChange(val => {
            if (currentEditableMesh) currentEditableMesh.material.color.set(val);
        }).onFinishChange(() => saveState());

        const sxCtrl = propFolder.add(guiParams, 'scaleX', 0.1, 10).name('ã‚µã‚¤ã‚º X').onChange(val => {
            if (currentEditableMesh) currentEditableMesh.scale.x = val;
        }).onFinishChange(() => saveState());

        const syCtrl = propFolder.add(guiParams, 'scaleY', 0.1, 10).name('ã‚µã‚¤ã‚º Y').onChange(val => {
            if (currentEditableMesh) currentEditableMesh.scale.y = val;
        }).onFinishChange(() => saveState());

        const szCtrl = propFolder.add(guiParams, 'scaleZ', 0.1, 10).name('ã‚µã‚¤ã‚º Z').onChange(val => {
            if (currentEditableMesh) currentEditableMesh.scale.z = val;
        }).onFinishChange(() => saveState());
        propFolder.open();

        const fileFolder = gui.addFolder('ğŸ’¾ ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ');
        fileFolder.add(guiParams, 'export').name('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ');
        fileFolder.add(guiParams, 'import').name('ã‚¤ãƒ³ãƒãƒ¼ãƒˆ');

        function updateGuiFromSelection() {
            if (!currentEditableMesh) return;
            guiParams.color = '#' + currentEditableMesh.material.color.getHexString();
            guiParams.scaleX = currentEditableMesh.scale.x;
            guiParams.scaleY = currentEditableMesh.scale.y;
            guiParams.scaleZ = currentEditableMesh.scale.z;
            colorCtrl.updateDisplay();
            sxCtrl.updateDisplay(); syCtrl.updateDisplay(); szCtrl.updateDisplay();
        }

        // --- ãƒ¢ãƒ¼ãƒ‰ç®¡ç†ï¼ˆé ‚ç‚¹ãƒ»é¢ï¼‰ ---
        function toggleVertexEditMode(enabled) {
            isVertexMode = enabled;
            if (enabled) { isFaceMode = false; guiParams.faceMode = false; faceMarkersGroup.clear(); createVertexMarkers(currentEditableMesh); }
            else { vertexMarkersGroup.clear(); if (currentEditableMesh) transformControls.attach(currentEditableMesh); }
        }
        function toggleFaceEditMode(enabled) {
            isFaceMode = enabled;
            if (enabled) { isVertexMode = false; guiParams.vertexMode = false; vertexMarkersGroup.clear(); createFaceMarkers(currentEditableMesh); }
            else { faceMarkersGroup.clear(); if (faceHighlighter) scene.remove(faceHighlighter); if (currentEditableMesh) transformControls.attach(currentEditableMesh); }
        }

        function createVertexMarkers(mesh) {
            vertexMarkersGroup.clear(); if (!mesh) return;
            const pos = mesh.geometry.attributes.position.array;
            const markerGeo = new THREE.SphereGeometry(0.08);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0xff0000, depthTest: false });
            const map = new Map();
            for (let i = 0; i < pos.length; i += 3) {
                const v = new THREE.Vector3(pos[i], pos[i+1], pos[i+2]);
                const key = `${v.x.toFixed(3)},${v.y.toFixed(3)},${v.z.toFixed(3)}`;
                if (!map.has(key)) {
                    const marker = new THREE.Mesh(markerGeo, markerMat.clone());
                    marker.position.copy(v.applyMatrix4(mesh.matrixWorld));
                    marker.userData = { isVertexMarker: true, indices: [i] };
                    vertexMarkersGroup.add(marker); map.set(key, marker);
                } else { map.get(key).userData.indices.push(i); }
            }
        }

        function createFaceMarkers(mesh) {
            faceMarkersGroup.clear(); if (!mesh) return;
            const pos = mesh.geometry.attributes.position.array;
            for (let i = 0; i < pos.length; i += 9) {
                const v1 = new THREE.Vector3(pos[i], pos[i+1], pos[i+2]);
                const v2 = new THREE.Vector3(pos[i+3], pos[i+4], pos[i+5]);
                const v3 = new THREE.Vector3(pos[i+6], pos[i+7], pos[i+8]);
                const center = new THREE.Vector3().add(v1).add(v2).add(v3).divideScalar(3);
                const marker = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshBasicMaterial({color: 0x00ffff}));
                marker.position.copy(center.applyMatrix4(mesh.matrixWorld));
                marker.userData = { isFaceMarker: true, faceIndex: i / 9 };
                faceMarkersGroup.add(marker);
            }
        }

        function extrudeFace() {
            if (!currentEditableMesh || selectedFaceIndex === -1) return;
            saveState();
            const mesh = currentEditableMesh; const oldPos = mesh.geometry.attributes.position.array; const idx = selectedFaceIndex * 9;
            const v1 = new THREE.Vector3(oldPos[idx], oldPos[idx+1], oldPos[idx+2]);
            const v2 = new THREE.Vector3(oldPos[idx+3], oldPos[idx+4], oldPos[idx+5]);
            const v3 = new THREE.Vector3(oldPos[idx+6], oldPos[idx+7], oldPos[idx+8]);
            const normal = new THREE.Vector3().crossVectors(v2.clone().sub(v1), v3.clone().sub(v1)).normalize();
            const offset = normal.multiplyScalar(0.5);
            const newVertices = Array.from(oldPos);
            const nv1 = v1.clone().add(offset), nv2 = v2.clone().add(offset), nv3 = v3.clone().add(offset);
            newVertices[idx] = nv1.x; newVertices[idx+1] = nv1.y; newVertices[idx+2] = nv1.z;
            newVertices[idx+3] = nv2.x; newVertices[idx+4] = nv2.y; newVertices[idx+5] = nv2.z;
            newVertices[idx+6] = nv3.x; newVertices[idx+7] = nv3.y; newVertices[idx+8] = nv3.z;
            const addSide = (a, b, na, nb) => {
                newVertices.push(a.x, a.y, a.z, b.x, b.y, b.z, na.x, na.y, na.z);
                newVertices.push(b.x, b.y, b.z, nb.x, nb.y, nb.z, na.x, na.y, na.z);
            };
            addSide(v1, v2, nv1, nv2); addSide(v2, v3, nv2, nv3); addSide(v3, v1, nv3, nv1);
            mesh.geometry.dispose(); mesh.geometry = new THREE.BufferGeometry();
            mesh.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(newVertices), 3));
            mesh.geometry.computeVertexNormals();
            createFaceMarkers(mesh); saveState();
        }

        // --- ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚° & ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« ---
        const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
        const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(10, 20, 10); scene.add(dir);
        scene.add(new THREE.GridHelper(20, 20));
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.set(5, 5, 5); controls.update();
        const transformControls = new THREE.TransformControls(camera, renderer.domElement);
        scene.add(transformControls);
        transformControls.addEventListener('dragging-changed', e => controls.enabled = !e.value);
        transformControls.addEventListener('objectChange', () => {
            if (isVertexMode && currentEditableMesh) {
                const pos = currentEditableMesh.geometry.attributes.position;
                const invMat = new THREE.Matrix4().copy(currentEditableMesh.matrixWorld).invert();
                vertexMarkersGroup.children.forEach(m => {
                    const local = m.position.clone().applyMatrix4(invMat);
                    m.userData.indices.forEach(idx => pos.setXYZ(idx/3, local.x, local.y, local.z));
                });
                pos.needsUpdate = true; currentEditableMesh.geometry.computeVertexNormals();
            }
        });

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        window.addEventListener('pointerdown', e => {
            if (transformControls.dragging) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            if (isVertexMode) {
                const hits = raycaster.intersectObjects(vertexMarkersGroup.children);
                if (hits.length > 0) transformControls.attach(hits[0].object);
            } else if (isFaceMode) {
                const hits = raycaster.intersectObjects(faceMarkersGroup.children);
                if (hits.length > 0) {
                    selectedFaceIndex = hits[0].object.userData.faceIndex;
                    if (faceHighlighter) scene.remove(faceHighlighter);
                    const pos = currentEditableMesh.geometry.attributes.position.array;
                    const idx = selectedFaceIndex * 9;
                    const geo = new THREE.BufferGeometry();
                    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([pos[idx], pos[idx+1], pos[idx+2], pos[idx+3], pos[idx+4], pos[idx+5], pos[idx+6], pos[idx+7], pos[idx+8]]), 3));
                    faceHighlighter = new THREE.Mesh(geo, highlightMaterial); faceHighlighter.applyMatrix4(currentEditableMesh.matrixWorld); scene.add(faceHighlighter);
                }
            } else {
                const hits = raycaster.intersectObjects(scene.children.filter(obj => obj.isMesh && !obj.userData.isMarker));
                if (hits.length > 0) { 
                    currentEditableMesh = hits[0].object; 
                    transformControls.attach(currentEditableMesh);
                    updateGuiFromSelection(); // é¸æŠæ™‚ã«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’æ›´æ–°
                }
            }
        });

        // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Ÿè¡Œ
        document.getElementById('confirmExportButton').addEventListener('click', () => {
            const format = document.getElementById('exportFormatSelect').value;
            if (format === 'json') {
                const link = document.createElement('a');
                link.href = 'data:text/json;charset=utf-8,' + encodeURIComponent(history.stack[history.index]);
                link.download = 'scene.json'; link.click();
            } else if (format === 'obj') {
                const exporter = new THREE.OBJExporter();
                const result = exporter.parse(scene);
                const blob = new Blob([result], { type: 'text/plain' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob); link.download = 'model.obj'; link.click();
            } else if (format === 'glb') {
                const exporter = new THREE.GLTFExporter();
                exporter.parse(scene, (result) => {
                    const blob = new Blob([result], { type: 'application/octet-stream' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob); link.download = 'model.glb'; link.click();
                }, { binary: true });
            }
            document.getElementById('exportModal').style.display = 'none';
        });

        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = (event) => applyState(event.target.result);
            reader.readAsText(file);
        });

        window.addEventListener('keydown', e => {
            if (e.key.toLowerCase() === 'v') { guiParams.vertexMode = !guiParams.vertexMode; toggleVertexEditMode(guiParams.vertexMode); }
            if (e.key.toLowerCase() === 'f') { guiParams.faceMode = !guiParams.faceMode; toggleFaceEditMode(guiParams.faceMode); }
            if (e.ctrlKey && e.key === 'z') undo();
        });

        function addBox() { const m = new THREE.Mesh(new THREE.BoxGeometry(1,1,1).toNonIndexed(), new THREE.MeshPhongMaterial({color: 0x0077ff})); m.position.y=0.5; scene.add(m); currentEditableMesh=m; transformControls.attach(m); updateGuiFromSelection(); saveState(); }
        function addSphere() { const m = new THREE.Mesh(new THREE.SphereGeometry(0.7,12,12).toNonIndexed(), new THREE.MeshPhongMaterial({color: 0x00ff77})); m.position.y=0.7; scene.add(m); currentEditableMesh=m; transformControls.attach(m); updateGuiFromSelection(); saveState(); }
        function addCylinder() { const m = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,1,12).toNonIndexed(), new THREE.MeshPhongMaterial({color: 0xff7700})); m.position.y=0.5; scene.add(m); currentEditableMesh=m; transformControls.attach(m); updateGuiFromSelection(); saveState(); }
        function addPlane() { const m = new THREE.Mesh(new THREE.PlaneGeometry(2,2).toNonIndexed(), new THREE.MeshPhongMaterial({color: 0x777777, side:2})); m.rotation.x=-Math.PI/2; scene.add(m); currentEditableMesh=m; transformControls.attach(m); updateGuiFromSelection(); saveState(); }

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate(); saveState();
    </script>
</body>
</html>
