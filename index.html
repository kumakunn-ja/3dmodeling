<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>Webãƒ–ãƒ©ã‚¦ã‚¶ 3Dãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã‚µã‚¤ãƒˆ (æ‹¡å¼µæ©Ÿèƒ½å¯¾å¿œ)</title>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        
        /* dat.GUIã®ä½ç½®èª¿æ•´ï¼ˆå³ä¸Šã®ãƒ‘ãƒãƒ«ï¼‰ */
        .dg.main { z-index: 100 !important; }

        /* ---------------------------------------------------- */
        /* å·¦ä¸Šã®ãƒ¢ãƒ‡ãƒ«è¿½åŠ UIã¨éšå±¤ãƒªã‚¹ãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ« */
        /* ---------------------------------------------------- */
        
        #left-panel-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            width: 250px;
            box-sizing: border-box;
            font-family: Menlo, "Lucida Console", Monaco, monospace;
            font-size: 11px;
        }

        #model-add-buttons {
            padding: 0; 
            background-color: #1a1a1a; 
            border: 0; 
            border-radius: 3px 3px 0 0;
            margin-bottom: 5px; /* éšå±¤ãƒªã‚¹ãƒˆã¨ã®é–“ã«ã‚¹ãƒšãƒ¼ã‚¹ */
        }
        
        #model-add-buttons h3 {
            margin: 0;
            padding: 4px 5px;
            font-size: 11px;
            font-weight: bold;
            color: #fff; 
            background-color: #000000; 
            border: none;
            cursor: pointer;
            line-height: 15px;
        }
        
        #model-add-buttons button {
            display: block; 
            width: 98%; 
            padding: 4px 0; 
            margin: 1px auto; 
            cursor: pointer;
            
            background-color: #333; 
            color: #fff; 
            border: 1px solid #333; 
            border-radius: 0; 
            font-size: 11px;
            text-align: center;
            
            height: 20px; 
            line-height: 20px; 
            box-sizing: border-box; 
        }
        
        #model-add-buttons button:hover {
            background-color: #444; 
            opacity: 1.0; 
        }

        /* éšå±¤ãƒªã‚¹ãƒˆ */
        #hierarchy-list {
            background-color: #1a1a1a;
            color: #fff;
            border-radius: 3px;
            padding: 5px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        #hierarchy-list ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #hierarchy-list li {
            padding: 3px 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #hierarchy-list li:hover {
            background-color: #444;
        }

        #hierarchy-list li.selected {
            background-color: #007bff;
        }

        .object-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .action-icon {
            margin-left: 5px;
            font-size: 12px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .action-icon:hover {
            opacity: 1.0;
        }

    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/OBJExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>

</head>
<body>
    <div id="left-panel-container">
        <div id="model-add-buttons">
            <h3>ğŸ“ ãƒ¢ãƒ‡ãƒ«ã®è¿½åŠ </h3>
            <button onclick="addBox()">ç«‹æ–¹ä½“ã‚’è¿½åŠ </button>
            <button onclick="addSphere()">çƒä½“ã‚’è¿½åŠ </button>
            <button onclick="addTorus()">ãƒ‰ãƒ¼ãƒŠãƒ„ã‚’è¿½åŠ </button>
            <button onclick="addCylinder()">å††æŸ±ã‚’è¿½åŠ </button> 
            <button onclick="addPlane()">å¹³é¢ã‚’è¿½åŠ </button> 
        </div>
        
        <div id="hierarchy-list">
            <h3>ğŸ—‚ï¸ ã‚·ãƒ¼ãƒ³éšå±¤</h3>
            <ul id="object-list">
                </ul>
        </div>
    </div>
    
    <input type="file" id="fileInput" style="display: none;">

    <div id="exportModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); z-index:200; font-family: sans-serif;">
        <div style="background-color:#fff; width:300px; margin:100px auto; padding:20px; border-radius:5px; box-shadow:0 0 10px #000;">
            <h3 style="margin-top:0;">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆè¨­å®š</h3>
            
            <label for="exportFormatSelect" style="display:block; margin-bottom: 5px;">å½¢å¼ã‚’é¸æŠ:</label>
            <select id="exportFormatSelect" style="width:100%; margin-bottom:15px; padding:8px; border: 1px solid #ccc; border-radius: 3px;">
                <option value="json">JSON (Three.js ã‚·ãƒ¼ãƒ³)</option>
                <option value="obj">OBJ (ã‚¸ã‚ªãƒ¡ãƒˆãƒª/ãƒãƒ†ãƒªã‚¢ãƒ«)</option>
                <option value="glb">GLB (ãƒã‚¤ãƒŠãƒª glTF)</option>
            </select>
            
            <div id="jsonOptions" style="margin-bottom:20px; padding: 10px; border: 1px solid #eee; border-radius: 3px; background-color: #f9f9f9;">
                <label>
                    <input type="checkbox" id="includeGeometryCheckbox" checked style="margin-right: 5px;">
                    ã‚¸ã‚ªãƒ¡ãƒˆãƒªãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚ã‚‹ (JSONã®ã¿)
                </label>
            </div>
            
            <button id="confirmExportButton" style="padding: 8px 15px; background-color:#007bff; color:white; border:none; border-radius:3px; cursor:pointer; margin-right:10px;">
                ä¿å­˜ã‚’å®Ÿè¡Œ
            </button>
            <button id="cancelExportButton" style="padding: 8px 15px; background-color:#ccc; border:none; border-radius:3px; cursor:pointer;">
                ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </button>
        </div>
    </div>
    
    <script>
        // ----------------------------------------------------
        // 1. å¤‰æ•°ã¨åˆæœŸè¨­å®š 
        // ----------------------------------------------------
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0); 
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé¸æŠã®ãŸã‚ã®Raycastingå¤‰æ•°
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // é ‚ç‚¹ç·¨é›†é–¢é€£ã®å¤‰æ•°
        const vertexMarkersGroup = new THREE.Group();
        vertexMarkersGroup.name = 'VertexMarkers';
        scene.add(vertexMarkersGroup);
        let isVertexMode = false;
        let currentEditableMesh = null;
        let uniqueVerticesMap = new Map();

        // ã‚«ãƒ¡ãƒ©ç§»å‹•è¨­å®š
        const moveSpeed = 0.1; 
        const keysPressed = {}; // æŠ¼ã•ã‚ŒãŸã‚­ãƒ¼ã®çŠ¶æ…‹ã‚’ä¿æŒ
        
        // GUIã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«å‚ç…§ç”¨
        let gui, positionFolder, rotationFolder, scaleFolder, materialFolder;


        // ----------------------------------------------------
        // 2. å…‰æºã®è¿½åŠ  (PBRå¯¾å¿œã®ãŸã‚ç’°å¢ƒå…‰+ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ)
        // ----------------------------------------------------
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3); 
        scene.add(ambientLight);

        // æ–°æ©Ÿèƒ½: ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®è¿½åŠ 
        const spotLight = new THREE.SpotLight(0xffffff, 1.0, 10, Math.PI / 4, 0.5, 2);
        spotLight.position.set(5, 10, 5);
        spotLight.castShadow = true;
        scene.add(spotLight);
        
        const spotLightHelper = new THREE.SpotLightHelper(spotLight);
        spotLightHelper.visible = false; 
        scene.add(spotLightHelper);


        // ----------------------------------------------------
        // 3. åºŠï¼ˆç‚¹ç·šã‚°ãƒªãƒƒãƒ‰ï¼‰ã®ä½œæˆã¨æ©Ÿèƒ½
        // ----------------------------------------------------
        
        const gridHelper = new THREE.GridHelper(20, 20, 0x000000, 0x555555);
        gridHelper.material.opacity = 0.5; 
        gridHelper.material.transparent = true; 
        gridHelper.position.y = 0; 
        gridHelper.name = 'GridHelper';
        scene.add(gridHelper);

        function toggleGroundPlane(isVisible) {
            gridHelper.visible = isVisible; 
        }

        // ----------------------------------------------------
        // 4. ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— (OrbitControls, TransformControls) 
        // ----------------------------------------------------

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.set(3, 3, 5); 
        controls.update();

        const transformControls = new THREE.TransformControls(camera, renderer.domElement);
        scene.add(transformControls);

        transformControls.addEventListener('dragging-changed', function(event) {
            controls.enabled = !event.value; 
            if (!event.value) {
                // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†æ™‚ã«GUIã¨éšå±¤ãƒªã‚¹ãƒˆã‚’æ›´æ–°
                if (transformControls.object) {
                    updateGUIForObject(transformControls.object);
                }
            }
        });
        
        transformControls.addEventListener('change', function() {
            // TransformControlsã®ç§»å‹•/å›è»¢/ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§GUIã«åæ˜ ã•ã›ã‚‹
            if (transformControls.object) {
                const selectedObject = transformControls.object;
                
                // Position, Scale, Rotationã‚’æ›´æ–°
                guiControls.posX = selectedObject.position.x;
                guiControls.posY = selectedObject.position.y;
                guiControls.posZ = selectedObject.position.z;
                
                guiControls.scaleX = selectedObject.scale.x;
                guiControls.scaleY = selectedObject.scale.y;
                guiControls.scaleZ = selectedObject.scale.z;
                
                guiControls.rotationX = THREE.MathUtils.radToDeg(selectedObject.rotation.x);
                guiControls.rotationY = THREE.MathUtils.radToDeg(selectedObject.rotation.y);
                guiControls.rotationZ = THREE.MathUtils.radToDeg(selectedObject.rotation.z);
                
                // GUIã‚’æ›´æ–°
                positionFolder.__controllers.forEach(controller => controller.updateDisplay());
                scaleFolder.__controllers.forEach(controller => controller.updateDisplay());
                rotationFolder.__controllers.forEach(controller => controller.updateDisplay());
            }

            // æ–°æ©Ÿèƒ½: ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
            if (guiControls.gridSnap && !isVertexMode && transformControls.mode === 'translate') {
                const step = guiControls.snapStep;
                const pos = transformControls.object.position;
                pos.x = Math.round(pos.x / step) * step;
                pos.y = Math.round(pos.y / step) * step;
                pos.z = Math.round(pos.z / step) * step;
            }

            if (isVertexMode && transformControls.object && transformControls.object.userData.isVertexMarker) {
                updateMeshGeometry(currentEditableMesh, transformControls.object);
            }
        });


        // ----------------------------------------------------
        // 5. é ‚ç‚¹ãƒãƒ¼ã‚«ãƒ¼æ“ä½œé–¢æ•° (å…ƒã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç¶­æŒ)
        // ----------------------------------------------------
        
        function isMeshEditable(mesh) {
            return mesh && (mesh.geometry.type === 'BoxGeometry' || mesh.geometry.type === 'PlaneGeometry' || mesh.geometry instanceof THREE.BufferGeometry);
        }
        // (createVertexMarkers, updateMeshGeometry, toggleVertexEditMode é–¢æ•°ã¯å…ƒã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç¶­æŒã—ã€çœç•¥)
        // ... (å…ƒã®ã‚³ãƒ¼ãƒ‰ã® 5. é ‚ç‚¹ãƒãƒ¼ã‚«ãƒ¼æ“ä½œé–¢æ•° ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ã“ã“ã«æŒ¿å…¥) ...
        
        // å…ƒã®ã‚³ãƒ¼ãƒ‰ã® 5. é ‚ç‚¹ãƒãƒ¼ã‚«ãƒ¼æ“ä½œé–¢æ•° ã®å†…å®¹ã‚’å†æ² (ç°¡ç•¥åŒ–ã®ãŸã‚ä¸­èº«ã®ã‚³ãƒ¼ãƒ‰ã¯çœç•¥ã—ã€é–¢æ•°å®šç¾©ã®ã¿æ®‹ã™)
        function createVertexMarkers(mesh) {
            vertexMarkersGroup.children.forEach(c => c.geometry.dispose());
            vertexMarkersGroup.children = []; 
            uniqueVerticesMap.clear();

            if (!isMeshEditable(mesh)) {
                vertexMarkersGroup.visible = false;
                return;
            }

            // ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’BufferGeometryã«å¤‰æ›ã—ã¦ç·¨é›†å¯èƒ½ã«ã™ã‚‹
            if (!(mesh.geometry instanceof THREE.BufferGeometry)) {
                mesh.geometry = new THREE.BufferGeometry().fromGeometry(mesh.geometry);
            }
            
            const geometry = mesh.geometry;
            const positions = geometry.attributes.position.array;
            const markerGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, depthTest: false });

            for (let i = 0; i < positions.length; i += 3) {
                const key = `${positions[i].toFixed(3)},${positions[i+1].toFixed(3)},${positions[i+2].toFixed(3)}`;
                
                if (!uniqueVerticesMap.has(key)) {
                    const marker = new THREE.Mesh(markerGeometry, markerMaterial.clone());
                    const localPos = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]);
                    marker.position.copy(localPos); 

                    marker.userData.isVertexMarker = true; 
                    
                    vertexMarkersGroup.add(marker);
                    uniqueVerticesMap.set(key, { 
                        marker: marker, 
                        indices: [i / 3]
                    });
                } else {
                    uniqueVerticesMap.get(key).indices.push(i / 3);
                }
            }
            vertexMarkersGroup.visible = false;
        }

        function updateMeshGeometry(mesh, marker) {
            if (!mesh || !(mesh.geometry instanceof THREE.BufferGeometry)) return;
            
            const positionAttribute = mesh.geometry.attributes.position;
            
            uniqueVerticesMap.forEach(item => {
                const markerPos = item.marker.position;
                
                item.indices.forEach(index => {
                    positionAttribute.setXYZ(index, markerPos.x, markerPos.y, markerPos.z);
                });
            });

            positionAttribute.needsUpdate = true;
            mesh.geometry.computeVertexNormals(); 
        }

        function toggleVertexEditMode(isEnabled) {
            const isEditable = isMeshEditable(currentEditableMesh);
            
            if (!isEditable) {
                 if (isEnabled) {
                    guiControls.vertexEditMode = false;
                    const controller = gui.__controllers.find(c => c.property === 'vertexEditMode');
                    if (controller) controller.updateDisplay();
                 }
                 isVertexMode = false;
                 return;
            }

            isVertexMode = isEnabled; 
            
            if (isVertexMode) {
                transformControls.detach(); 
                currentEditableMesh.visible = false; 
                vertexMarkersGroup.visible = true; 
                
                currentEditableMesh.updateWorldMatrix(true, false);
                currentEditableMesh.geometry.applyMatrix4(currentEditableMesh.matrixWorld);

                currentEditableMesh.position.set(0, 0, 0);
                currentEditableMesh.rotation.set(0, 0, 0);
                currentEditableMesh.scale.set(1, 1, 1);
                currentEditableMesh.updateMatrixWorld(true);

                vertexMarkersGroup.position.set(0, 0, 0);
                vertexMarkersGroup.rotation.set(0, 0, 0);
                vertexMarkersGroup.scale.set(1, 1, 1);

                createVertexMarkers(currentEditableMesh);
                
                if (vertexMarkersGroup.children.length > 0) {
                    transformControls.attach(vertexMarkersGroup.children[0]);
                    transformControls.setMode('translate');
                } else {
                    guiControls.vertexEditMode = false;
                    const controller = gui.__controllers.find(c => c.property === 'vertexEditMode');
                    if (controller) controller.updateDisplay();
                    isVertexMode = false;
                }
            } else {
                transformControls.detach(); 
                currentEditableMesh.visible = true; 
                vertexMarkersGroup.visible = false; 

                vertexMarkersGroup.children.forEach(c => c.geometry.dispose());
                vertexMarkersGroup.children = [];
                uniqueVerticesMap.clear();
                
                transformControls.attach(currentEditableMesh); 
                updateGUIForObject(currentEditableMesh); 
            }
            // é ‚ç‚¹ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆæ™‚ã«ã€ç¾åœ¨ã®ãƒ¢ãƒ‡ãƒ«ã®GUIã‚’æ›´æ–°
            updateGUIForObject(currentEditableMesh);
        }

        // ----------------------------------------------------
        // 6. åˆæœŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆã¨dat.GUIã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— 
        // ----------------------------------------------------

        const geometry = new THREE.BoxGeometry(1, 1, 1);
        // ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’PBR (Standard) ã«å¤‰æ›´
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x0077ff,
            metalness: 0.1, // PBRãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
            roughness: 0.8  // PBRãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        }); 
        const cube = new THREE.Mesh(geometry, material);
        cube.name = 'Cube_1'; 
        cube.position.y = 0.5; 
        scene.add(cube);
        
        currentEditableMesh = cube;
        createVertexMarkers(currentEditableMesh); 
        
        transformControls.attach(cube); 

        // GUIã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ‹¡å¼µ
        const guiControls = {
            // PBR ãƒãƒ†ãƒªã‚¢ãƒ«
            color: '#0077ff', 
            metalness: 0.1,
            roughness: 0.8,
            emissive: '#000000',

            visible: true,
            wireframe: false, 
            
            // æ–°æ©Ÿèƒ½: Position (çµ¶å¯¾ä½ç½®)
            posX: cube.position.x,
            posY: cube.position.y,
            posZ: cube.position.z,

            // Scale
            scaleX: 1.0,
            scaleY: 1.0,
            scaleZ: 1.0,

            // Rotation
            rotationX: 0, 
            rotationY: 0, 
            rotationZ: 0, 
            
            // ãƒ¢ãƒ‡ãƒªãƒ³ã‚°æ©Ÿèƒ½
            vertexEditMode: false,
            gridSnap: false, // æ–°æ©Ÿèƒ½: ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
            snapStep: 0.5,    // æ–°æ©Ÿèƒ½: ã‚¹ãƒŠãƒƒãƒ—é–“éš”

            // ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹
            toggleGround: true,
            
            // æ–°æ©Ÿèƒ½: ãƒ©ã‚¤ãƒˆè¨­å®š
            lightX: spotLight.position.x,
            lightY: spotLight.position.y,
            lightZ: spotLight.position.z,
            lightIntensity: spotLight.intensity,
            lightVisible: true
        };

        gui = new dat.GUI();

        // --- ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ ---
        const workspaceFolder = gui.addFolder('ğŸ–¥ï¸ ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹');
        workspaceFolder.open();

        workspaceFolder.add(guiControls, 'toggleGround')
            .name('åºŠ (ã‚°ãƒªãƒƒãƒ‰) ã‚’è¡¨ç¤º')
            .onChange(toggleGroundPlane);
            
        workspaceFolder.add(guiControls, 'gridSnap') // æ–°æ©Ÿèƒ½: ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
            .name('ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ— (ç§»å‹•)')
            .onChange(function(value) {
                // ã‚¹ãƒŠãƒƒãƒ—ã®æœ‰åŠ¹åŒ–/ç„¡åŠ¹åŒ–ã€‚TransformControlsã®changeã‚¤ãƒ™ãƒ³ãƒˆå†…ã§å‡¦ç†
            });
            
        workspaceFolder.add(guiControls, 'snapStep', 0.1, 1.0, 0.1) // æ–°æ©Ÿèƒ½: ã‚¹ãƒŠãƒƒãƒ—é–“éš”
            .name('ã‚¹ãƒŠãƒƒãƒ—é–“éš”');

        // --- ãƒ©ã‚¤ãƒˆè¨­å®š ---
        const lightFolder = gui.addFolder('ğŸ’¡ ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆè¨­å®š');
        lightFolder.open();
        
        lightFolder.add(guiControls, 'lightVisible').name('ãƒ©ã‚¤ãƒˆã‚’è¡¨ç¤º').onChange(function(value) {
            spotLight.visible = value;
            spotLightHelper.visible = value;
        });

        lightFolder.add(guiControls, 'lightIntensity', 0, 5, 0.1).name('å¼·åº¦').onChange(function(value) {
            spotLight.intensity = value;
        });
        
        lightFolder.add(guiControls, 'lightX', -10, 10, 0.1).name('ä½ç½® X').onChange(function(value) {
            spotLight.position.x = value;
            spotLightHelper.update();
        });
        lightFolder.add(guiControls, 'lightY', 0, 20, 0.1).name('ä½ç½® Y').onChange(function(value) {
            spotLight.position.y = value;
            spotLightHelper.update();
        });
        lightFolder.add(guiControls, 'lightZ', -10, 10, 0.1).name('ä½ç½® Z').onChange(function(value) {
            spotLight.position.z = value;
            spotLightHelper.update();
        });


        // --- ãƒ¢ãƒ‡ãƒªãƒ³ã‚°/ãƒãƒ†ãƒªã‚¢ãƒ« ---
        
        // é ‚ç‚¹ç·¨é›†ãƒ¢ãƒ¼ãƒ‰
        gui.add(guiControls, 'vertexEditMode')
            .name('é ‚ç‚¹ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ (V)')
            .onChange(function(value) {
                toggleVertexEditMode(value);
            });
            
        materialFolder = gui.addFolder('ğŸ¨ ãƒãƒ†ãƒªã‚¢ãƒ« (PBR)');
        materialFolder.open();
        
        materialFolder.addColor(guiControls, 'color').name('åŸºæœ¬è‰² (Albedo)').onChange(updateMaterialProperties);
        materialFolder.add(guiControls, 'metalness', 0, 1, 0.01).name('ãƒ¡ã‚¿ãƒªãƒƒã‚¯').onChange(updateMaterialProperties);
        materialFolder.add(guiControls, 'roughness', 0, 1, 0.01).name('ãƒ©ãƒ•ãƒã‚¹').onChange(updateMaterialProperties);
        materialFolder.addColor(guiControls, 'emissive').name('ç™ºå…‰è‰²').onChange(updateMaterialProperties);

        materialFolder.add(guiControls, 'wireframe')
            .name('ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤º')
            .onChange(function(value) {
                const target = isVertexMode ? currentEditableMesh : transformControls.object;
                if (target && target.material) {
                    target.material.wireframe = value;
                }
            });

        // å¯è¦–æ€§
        gui.add(guiControls, 'visible').onChange(function(value) {
             if (transformControls.object && !isVertexMode) {
                transformControls.object.visible = value;
                updateHierarchyList(); // éšå±¤ãƒªã‚¹ãƒˆã‚‚æ›´æ–°
            }
        }).name('Selected Model Visible');


        // --- å¤‰æ› (Position, Scale, Rotation) ---
        
        // æ–°æ©Ÿèƒ½: Position Folder (çµ¶å¯¾ä½ç½®)
        positionFolder = gui.addFolder('ğŸ“ Position');
        positionFolder.open();
        
        positionFolder.add(guiControls, 'posX', -10, 10, 0.01).name('Position X').onChange(function(value) {
            if (transformControls.object && !isVertexMode) {
                transformControls.object.position.x = value;
            }
        });
        positionFolder.add(guiControls, 'posY', -10, 10, 0.01).name('Position Y').onChange(function(value) {
            if (transformControls.object && !isVertexMode) {
                transformControls.object.position.y = value;
            }
        });
        positionFolder.add(guiControls, 'posZ', -10, 10, 0.01).name('Position Z').onChange(function(value) {
            if (transformControls.object && !isVertexMode) {
                transformControls.object.position.z = value;
            }
        });


        scaleFolder = gui.addFolder('ğŸ“ Size (Scale)');
        scaleFolder.open(); 
        
        const minScale = 0.001; 
        const stepScale = 0.1; 

        scaleFolder.add(guiControls, 'scaleX', minScale, 10, stepScale).name('Width (X)').onChange(function(value) {
            if (transformControls.object && !isVertexMode) {
                if (value < minScale || isNaN(value)) { value = minScale; }
                transformControls.object.scale.x = value;
            }
        });

        scaleFolder.add(guiControls, 'scaleY', minScale, 10, stepScale).name('Height (Y)').onChange(function(value) {
            if (transformControls.object && !isVertexMode) {
                if (value < minScale || isNaN(value)) { value = minScale; }
                transformControls.object.scale.y = value;
            }
        });

        scaleFolder.add(guiControls, 'scaleZ', minScale, 10, stepScale).name('Depth (Z)').onChange(function(value) {
            if (transformControls.object && !isVertexMode) {
                if (value < minScale || isNaN(value)) { value = minScale; }
                transformControls.object.scale.z = value;
            }
        });
        
        rotationFolder = gui.addFolder('ğŸ”„ Rotation');
        rotationFolder.open();
        
        rotationFolder.add(guiControls, 'rotationX', -180, 180, 1).name('Rotation X').onChange(function(value) {
            if (transformControls.object && !isVertexMode) {
                transformControls.object.rotation.x = THREE.MathUtils.degToRad(value);
            }
        });
        
        rotationFolder.add(guiControls, 'rotationY', -180, 180, 1).name('Rotation Y').onChange(function(value) {
            if (transformControls.object && !isVertexMode) {
                transformControls.object.rotation.y = THREE.MathUtils.degToRad(value);
            }
        });
        
        rotationFolder.add(guiControls, 'rotationZ', -180, 180, 1).name('Rotation Z').onChange(function(value) {
            if (transformControls.object && !isVertexMode) {
                transformControls.object.rotation.z = THREE.MathUtils.degToRad(value);
            }
        });

        // --- ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œãƒ•ã‚©ãƒ«ãƒ€ ---
        const fileFolder = gui.addFolder('ğŸ’¾ ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ');
        fileFolder.open();

        const fileControls = {
            openExportModal: function() { 
                document.getElementById('exportModal').style.display = 'block';
                document.getElementById('jsonOptions').style.display = 
                    (document.getElementById('exportFormatSelect').value === 'json' ? 'block' : 'none');
            },
            import: function() {
                document.getElementById('fileInput').click();
            }
        };

        fileFolder.add(fileControls, 'openExportModal').name('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Ÿè¡Œ'); 
        fileFolder.add(fileControls, 'import').name('ã‚·ãƒ¼ãƒ³ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ');
        
        // --- ãƒãƒ†ãƒªã‚¢ãƒ«æ›´æ–°ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ---
        function updateMaterialProperties() {
            const target = isVertexMode ? currentEditableMesh : transformControls.object;
            if (target && target.material) {
                target.material.color.set(guiControls.color);
                if (target.material.metalness !== undefined) {
                    target.material.metalness = guiControls.metalness;
                }
                if (target.material.roughness !== undefined) {
                    target.material.roughness = guiControls.roughness;
                }
                if (target.material.emissive !== undefined) {
                    target.material.emissive.set(guiControls.emissive);
                }
                target.material.needsUpdate = true;
            }
        }

        // ----------------------------------------------------
        // 7. æ–°ã—ã„å›³å½¢ã‚’è¿½åŠ ã™ã‚‹é–¢æ•° 
        // ----------------------------------------------------
        
        let meshCounter = 2; 

        function createRandomMaterial() {
            const randomColor = Math.random() * 0xffffff;
            // PBR (Standard) ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½¿ç”¨
            const newMaterial = new THREE.MeshStandardMaterial({ 
                color: randomColor,
                metalness: 0.1,
                roughness: 0.8
            });
            
            guiControls.color = '#' + newMaterial.color.getHexString();
            guiControls.metalness = 0.1;
            guiControls.roughness = 0.8;
            guiControls.emissive = '#000000';
            
            guiControls.wireframe = newMaterial.wireframe || false; 

            // GUIã®æ›´æ–°
            const controllers = gui.__controllers.concat(materialFolder.__controllers);
            controllers.forEach(c => c.updateDisplay());

            return newMaterial;
        }

        function addObject(geometry, typeName, initialRotation = new THREE.Euler(0, 0, 0)) {
            if (isVertexMode) toggleVertexEditMode(false); 

            const material = createRandomMaterial();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = `${typeName}_${meshCounter++}`; 
            
            mesh.rotation.copy(initialRotation);

            let initialYOffset = 0.5;
            if (geometry.parameters.height !== undefined) {
                initialYOffset = geometry.parameters.height / 2;
            } else if (geometry.parameters.radius !== undefined) {
                initialYOffset = geometry.parameters.radius;
            }
            if (typeName === 'Plane') {
                initialYOffset = 0.001; 
            }
            
            mesh.position.set(
                Math.random() * 4 - 2, 
                initialYOffset,
                Math.random() * 4 - 2
            );

            scene.add(mesh);
            selectObject(mesh); // è¿½åŠ å¾Œã«é¸æŠ
            updateHierarchyList(); // æ–°æ©Ÿèƒ½: éšå±¤ãƒªã‚¹ãƒˆã‚’æ›´æ–°
            return mesh; 
        }

        function addBox() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            addObject(geometry, 'Cube');
        }

        function addSphere() {
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            addObject(geometry, 'Sphere');
        }

        function addTorus() {
            const geometry = new THREE.TorusGeometry(1, 0.4, 16, 100);
            addObject(geometry, 'Torus');
        }
        
        function addCylinder() {
            const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32); 
            addObject(geometry, 'Cylinder');
        }
        
        function addPlane() {
            const geometry = new THREE.PlaneGeometry(2, 2); 
            const initialRotation = new THREE.Euler(-Math.PI / 2, 0, 0);
            addObject(geometry, 'Plane', initialRotation);
        }
        
        function duplicateSelectedObject() {
            const selectedObject = transformControls.object;
            if (!selectedObject || isVertexMode) return;

            const clonedObject = selectedObject.clone();
            
            if (clonedObject.geometry instanceof THREE.BufferGeometry) {
                 clonedObject.geometry = clonedObject.geometry.clone();
            }

            clonedObject.position.x += 0.5;
            clonedObject.position.z += 0.5;
            
            clonedObject.name = `${selectedObject.name}_Clone_${meshCounter++}`;
            
            scene.add(clonedObject);
            selectObject(clonedObject); // è¤‡è£½å¾Œã«é¸æŠ
            updateHierarchyList(); // æ–°æ©Ÿèƒ½: éšå±¤ãƒªã‚¹ãƒˆã‚’æ›´æ–°
        }
        
        function selectObject(mesh) {
            transformControls.attach(mesh);
            currentEditableMesh = mesh;
            if (isMeshEditable(currentEditableMesh)) {
                 createVertexMarkers(currentEditableMesh);
            } else {
                 createVertexMarkers(null); 
            }
            updateGUIForObject(mesh);
            updateHierarchyList(); // éšå±¤ãƒªã‚¹ãƒˆã®é¸æŠçŠ¶æ…‹ã‚’æ›´æ–°
        }
        
        function deleteSelectedObject() {
             if (transformControls.object) {
                const objectToDelete = transformControls.object;
                if (isVertexMode) {
                    toggleVertexEditMode(false); 
                } 
                scene.remove(objectToDelete);
                objectToDelete.geometry.dispose();
                objectToDelete.material.dispose();
                
                transformControls.detach(); 
                currentEditableMesh = null;
                
                updateHierarchyList(); // éšå±¤ãƒªã‚¹ãƒˆã‚’æ›´æ–°
            }
        }


        // ----------------------------------------------------
        // 8. éšå±¤ãƒªã‚¹ãƒˆæ©Ÿèƒ½ (æ–°æ©Ÿèƒ½)
        // ----------------------------------------------------
        
        function updateHierarchyList() {
            const listElement = document.getElementById('object-list');
            listElement.innerHTML = '';
            
            const selectedObject = transformControls.object;

            scene.traverse(function(object) {
                if (object.isMesh && object !== gridHelper && object.parent === scene) {
                    
                    const listItem = document.createElement('li');
                    listItem.dataset.name = object.name;
                    listItem.id = 'list-item-' + object.uuid;
                    
                    if (selectedObject && selectedObject.uuid === object.uuid) {
                        listItem.classList.add('selected');
                    }
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'object-name';
                    nameSpan.textContent = object.name;
                    listItem.appendChild(nameSpan);

                    // å¯è¦–æ€§ãƒˆã‚°ãƒ«
                    const visibleIcon = document.createElement('span');
                    visibleIcon.className = 'action-icon';
                    visibleIcon.textContent = object.visible ? 'ğŸ‘ï¸' : 'ğŸš«';
                    visibleIcon.title = object.visible ? 'éè¡¨ç¤º' : 'è¡¨ç¤º';
                    visibleIcon.onclick = function(event) {
                        event.stopPropagation();
                        object.visible = !object.visible;
                        updateHierarchyList(); // ã‚¢ã‚¤ã‚³ãƒ³ã¨GUIã‚’æ›´æ–°
                        if (selectedObject && selectedObject.uuid === object.uuid) {
                             guiControls.visible = object.visible;
                             gui.__controllers.find(c => c.property === 'visible').updateDisplay();
                        }
                    };
                    listItem.appendChild(visibleIcon);

                    // å‰Šé™¤ãƒœã‚¿ãƒ³
                    const deleteIcon = document.createElement('span');
                    deleteIcon.className = 'action-icon';
                    deleteIcon.textContent = 'ğŸ—‘ï¸';
                    deleteIcon.title = 'å‰Šé™¤';
                    deleteIcon.onclick = function(event) {
                        event.stopPropagation();
                        if (confirm(`${object.name} ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
                            // å‰Šé™¤å‡¦ç†ã¯ deleteSelectedObject ã¨åŒæ§˜ã ãŒã€æŒ‡å®šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤
                            if (transformControls.object && transformControls.object.uuid === object.uuid) {
                                deleteSelectedObject();
                            } else {
                                scene.remove(object);
                                object.geometry.dispose();
                                object.material.dispose();
                                updateHierarchyList();
                            }
                        }
                    };
                    listItem.appendChild(deleteIcon);
                    
                    listItem.onclick = function() {
                        selectObject(object);
                    };

                    listElement.appendChild(listItem);
                }
            });
        }


        // ----------------------------------------------------
        // 9. ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½ (å…ƒã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç¶­æŒ)
        // ----------------------------------------------------

        // ... (exportSceneJSON, exportSceneOBJ, exportSceneGLB, saveString, saveArrayBuffer é–¢æ•°ã¯å…ƒã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç¶­æŒã—ã€çœç•¥) ...
        // ... (importScene é–¢æ•°ã¯å…ƒã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç¶­æŒã—ã€çœç•¥ã€‚ãŸã ã—ã€importSceneã®æœ€å¾Œã§ updateHierarchyList() ã‚’å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚‹) ...

        function importScene(jsonString) {
            // ... (ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ­ã‚¸ãƒƒã‚¯: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒªã‚¢ã—ã€JSONã‹ã‚‰å†æ§‹ç¯‰) ...
            
            // NOTE: ã“ã“ã«å…ƒã® importScene ã®ãƒ­ã‚¸ãƒƒã‚¯å…¨ä½“ã‚’æŒ¿å…¥ã—ã¦ãã ã•ã„ã€‚
            // ç°¡ç•¥åŒ–ã®ãŸã‚ã€ã“ã“ã§ã¯æœ€å¾Œã®å‡¦ç†ã®ã¿è¨˜è¿°ã—ã¾ã™ã€‚
            
            // (ä¸­ç•¥ - JSONè§£æã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆ)
            
            // ...
            // if (currentEditableMesh) {
            //      updateGUIForObject(currentEditableMesh); 
            // }
            
            // alert(`ã‚·ãƒ¼ãƒ³ã«${importedCount}å€‹ã®ãƒ¢ãƒ‡ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚`);

            // â˜…è¿½åŠ : ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¾Œã€éšå±¤ãƒªã‚¹ãƒˆã‚’æ›´æ–°
            updateHierarchyList();
        }

        function updateGUIForObject(selectedObject) {
            // PBR Material ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’åæ˜ 
            const material = selectedObject.material;
            const hexColor = '#' + material.color.getHexString();
            guiControls.color = hexColor;
            
            if (material.metalness !== undefined) {
                 guiControls.metalness = material.metalness;
            }
            if (material.roughness !== undefined) {
                 guiControls.roughness = material.roughness;
            }
            if (material.emissive !== undefined) {
                 guiControls.emissive = '#' + material.emissive.getHexString();
            }

            // æ–°æ©Ÿèƒ½: Position (çµ¶å¯¾ä½ç½®) ã®åæ˜ 
            guiControls.posX = selectedObject.position.x;
            guiControls.posY = selectedObject.position.y;
            guiControls.posZ = selectedObject.position.z;
            
            guiControls.scaleX = selectedObject.scale.x;
            guiControls.scaleY = selectedObject.scale.y;
            guiControls.scaleZ = selectedObject.scale.z;
            
            guiControls.rotationX = THREE.MathUtils.radToDeg(selectedObject.rotation.x);
            guiControls.rotationY = THREE.MathUtils.radToDeg(selectedObject.rotation.y);
            guiControls.rotationZ = THREE.MathUtils.radToDeg(selectedObject.rotation.z);
            
            guiControls.visible = selectedObject.visible;
            guiControls.wireframe = selectedObject.material.wireframe; 
            
            // ã™ã¹ã¦ã®GUIã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’æ›´æ–°
            gui.__controllers.forEach(controller => controller.updateDisplay());
            gui.__folders['ğŸ¨ ãƒãƒ†ãƒªã‚¢ãƒ« (PBR)'].__controllers.forEach(controller => controller.updateDisplay());
            positionFolder.__controllers.forEach(controller => controller.updateDisplay());
            scaleFolder.__controllers.forEach(controller => controller.updateDisplay());
            rotationFolder.__controllers.forEach(controller => controller.updateDisplay());

        }


        // ----------------------------------------------------
        // 10. ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé¸æŠãƒ­ã‚¸ãƒƒã‚¯ (Raycasting)
        // ----------------------------------------------------

        function onPointerDown(event) {
            if (transformControls.dragging) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            if (isVertexMode) {
                const markers = vertexMarkersGroup.children;
                const intersects = raycaster.intersectObjects(markers, false);

                markers.forEach(m => m.material.color.set(0xff0000));
                
                if (intersects.length > 0) {
                    const selectedMarker = intersects[0].object;
                    transformControls.attach(selectedMarker);
                    selectedMarker.material.color.set(0x00ff00);
                    transformControls.setMode('translate');
                } else {
                    transformControls.detach();
                }

            } else {
                const objects = scene.children.filter(obj => obj.isMesh && obj !== gridHelper);
                const intersects = raycaster.intersectObjects(objects, true);

                if (intersects.length > 0) {
                    const selectedObject = intersects[0].object;
                    selectObject(selectedObject);
                } else {
                    // ä½•ã‚‚é¸æŠã•ã‚Œãªã‹ã£ãŸå ´åˆã¯ TransformControls ã‚’ãƒ‡ã‚¿ãƒƒãƒ
                    transformControls.detach();
                    currentEditableMesh = null;
                    createVertexMarkers(null); // ãƒãƒ¼ã‚«ãƒ¼ã‚’ã‚¯ãƒªã‚¢
                    updateHierarchyList();
                }
            }
        }

        // ----------------------------------------------------
        // 11. ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        // ----------------------------------------------------
        
        window.addEventListener('pointerdown', onPointerDown, false);

        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®å‡¦ç†
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    importScene(e.target.result);
                };
                reader.readAsText(file);
            }
        }, false);
        
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã®è¨­å®š
        window.addEventListener('keydown', function(event) {
            keysPressed[event.key.toLowerCase()] = true; 
            
            // Ctrl + D (è¤‡è£½) ã®å‡¦ç†
            if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'd') { 
                event.preventDefault(); 
                duplicateSelectedObject();
                return;
            }
            
            switch (event.key.toLowerCase()) {
                case 't': 
                    transformControls.setMode('translate');
                    break;
                case 'r': 
                    if (!isVertexMode) transformControls.setMode('rotate'); 
                    break;
                case 's': 
                    if (!isVertexMode) transformControls.setMode('scale');  
                    break;
                case 'v': 
                    const isEditable = isMeshEditable(currentEditableMesh); 

                    if (isEditable) {
                        guiControls.vertexEditMode = !guiControls.vertexEditMode;
                        const controller = gui.__controllers.find(c => c.property === 'vertexEditMode');
                        if (controller) controller.setValue(guiControls.vertexEditMode);
                    }
                    break;
                case 'delete': 
                case 'backspace': // Macã®Deleteã‚­ãƒ¼ã«å¯¾å¿œ
                    deleteSelectedObject();
                    event.preventDefault(); 
                    break;
            }
        });

        window.addEventListener('keyup', function(event) {
            keysPressed[event.key.toLowerCase()] = false;
        });
        
        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š (å…ƒã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç¶­æŒ)
        const modal = document.getElementById('exportModal');
        const formatSelect = document.getElementById('exportFormatSelect');
        const includeGeometryCheckbox = document.getElementById('includeGeometryCheckbox');
        const jsonOptionsDiv = document.getElementById('jsonOptions');
        const confirmButton = document.getElementById('confirmExportButton');
        const cancelButton = document.getElementById('cancelExportButton');

        formatSelect.addEventListener('change', function() {
            jsonOptionsDiv.style.display = (formatSelect.value === 'json' ? 'block' : 'none');
        });

        cancelButton.addEventListener('click', function() {
            modal.style.display = 'none';
        });

        confirmButton.addEventListener('click', function() {
            modal.style.display = 'none';

            const format = formatSelect.value;
            const includeGeo = includeGeometryCheckbox.checked;

            switch (format) {
                case 'json':
                    exportSceneJSON(includeGeo); 
                    break;
                case 'obj':
                    exportSceneOBJ();
                    break;
                case 'glb':
                    exportSceneGLB();
                    break;
                default:
                    alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
            }
        });


        // ----------------------------------------------------
        // 12. ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ— / åˆæœŸåŒ–
        // ----------------------------------------------------

        function handleCameraMovement() {
            // (ã‚«ãƒ¡ãƒ©ç§»å‹•ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯å…ƒã®ã‚³ãƒ¼ãƒ‰ã¨åŒã˜ãŸã‚çœç•¥)
            let moved = false;
            
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction); 
            direction.y = 0; 
            direction.normalize();

            const right = new THREE.Vector3().crossVectors(direction, camera.up);

            if (keysPressed['w']) {
                camera.position.addScaledVector(direction, moveSpeed); 
                moved = true;
            }
            if (keysPressed['s']) {
                camera.position.addScaledVector(direction, -moveSpeed); 
                moved = true;
            }
            if (keysPressed['a']) {
                camera.position.addScaledVector(right, -moveSpeed); 
                moved = true;
            }
            if (keysPressed['d']) {
                camera.position.addScaledVector(right, moveSpeed); 
                moved = true;
            }
            
            if (moved) {
                controls.enabled = false;
                
                controls.target.addScaledVector(direction, keysPressed['w'] ? moveSpeed : (keysPressed['s'] ? -moveSpeed : 0));
                controls.target.addScaledVector(right, keysPressed['d'] ? moveSpeed : (keysPressed['a'] ? -moveSpeed : 0));
            } else if (!transformControls.dragging) {
                controls.enabled = true;
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            handleCameraMovement(); 
            
            controls.update(); 
            renderer.render(scene, camera);
        }

        animate();
        updateHierarchyList(); // åˆæœŸåŒ–æ™‚ã«éšå±¤ãƒªã‚¹ãƒˆã‚’ä¸€åº¦ä½œæˆ
        
        // ----------------------------------------------------
        // 13. ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºå¤‰æ›´å¯¾å¿œ
        // ----------------------------------------------------
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
