<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>Web 3D Modeler - Shadow & Edit Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: sans-serif; }
        .dg.main { z-index: 100 !important; }
        #model-add-buttons {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            width: 200px; background: rgba(30,30,30,0.9); color: white; padding: 10px; border-radius: 8px;
        }
        #model-add-buttons button {
            display: block; width: 100%; margin: 5px 0; padding: 6px; cursor: pointer;
            background: #444; color: white; border: 1px solid #555; border-radius: 4px;
            font-size: 12px;
        }
        #model-add-buttons button:hover { background: #666; }
        #exportModal {
            display:none; position:fixed; top:0; left:0; width:100%; height:100%; 
            background:rgba(0,0,0,0.7); z-index:200;
        }
        .modal-content { background:#fff; width:300px; margin:100px auto; padding:20px; border-radius:5px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/OBJExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
</head>
<body>
    <div id="model-add-buttons">
        <strong>üìê „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàËøΩÂä†</strong>
        <button onclick="addMesh('box')">Á´ãÊñπ‰Ωì</button>
        <button onclick="addMesh('sphere')">ÁêÉ‰Ωì</button>
        <button onclick="addMesh('cylinder')">ÂÜÜÊü±</button>
        <button onclick="addMesh('plane')">Âπ≥Èù¢</button>
    </div>
    <input type="file" id="fileInput" style="display: none;">

    <div id="exportModal">
        <div class="modal-content">
            <h3>„Ç®„ÇØ„Çπ„Éù„Éº„Éà</h3>
            <select id="exportFormat" style="width:100%; margin-bottom:15px; padding:5px;">
                <option value="json">JSON (Á∑®ÈõÜÁî®„Éá„Éº„Çø)</option>
                <option value="obj">OBJ (Â§ñÈÉ®„ÇΩ„Éï„ÉàÁî®)</option>
                <option value="glb">GLB (Ê±éÁî®3DÂΩ¢Âºè)</option>
            </select>
            <button id="doExport" style="background:#007bff; color:white; border:none; padding:8px 15px; cursor:pointer;">‰øùÂ≠ò</button>
            <button onclick="document.getElementById('exportModal').style.display='none'">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <script>
        // --- 1. Âü∫Êú¨Ë®≠ÂÆö ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);
        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // ÂΩ±„ÇíÊúâÂäπ
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        const transformControls = new THREE.TransformControls(camera, renderer.domElement);
        scene.add(transformControls);
        transformControls.addEventListener('dragging-changed', e => controls.enabled = !e.value);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(5, 10, 7); 
        dirLight.castShadow = true; 
        dirLight.shadow.mapSize.set(1024, 1024);
        scene.add(dirLight);

        const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), new THREE.MeshPhongMaterial({ color: 0x444444 }));
        floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; scene.add(floor);
        scene.add(new THREE.GridHelper(20, 20, 0x888888, 0x444444));

        let currentMesh = null;
        let isVertexMode = false, isFaceMode = false;
        let selectedFaceIndex = -1;
        const vertexMarkers = new THREE.Group();
        const faceMarkers = new THREE.Group();
        const highlightMat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.5, transparent: true, side: 2 });
        let faceHighlighter = null;
        scene.add(vertexMarkers, faceMarkers);

        // --- 2. Áä∂ÊÖã„ÉªÂ±•Ê≠¥ (Undo & AutoSave) ---
        const history = { stack: [], index: -1 };
        function saveState() {
            const meshes = [];
            scene.traverse(obj => {
                if (obj.isMesh && !obj.userData.isMarker && obj !== floor && obj.name !== "Highlighter") {
                    meshes.push({
                        pos: obj.position.toArray(), rot: obj.rotation.toArray(), scale: obj.scale.toArray(),
                        color: '#' + obj.material.color.getHexString(), wire: obj.material.wireframe,
                        verts: Array.from(obj.geometry.attributes.position.array)
                    });
                }
            });
            const state = JSON.stringify(meshes);
            if (history.index < history.stack.length - 1) history.stack = history.stack.slice(0, history.index + 1);
            history.stack.push(state); history.index++;
            localStorage.setItem('3d_modeler_save', state);
        }

        function applyState(stateData) {
            if(!stateData) return;
            const data = JSON.parse(stateData);
            scene.children.filter(obj => obj.isMesh && !obj.userData.isMarker && obj !== floor && obj.name !== "Highlighter").forEach(obj => {
                scene.remove(obj); obj.geometry.dispose(); obj.material.dispose();
            });
            data.forEach(d => {
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(d.verts), 3));
                geo.computeVertexNormals();
                const mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: d.color, wireframe: d.wire }));
                mesh.position.fromArray(d.pos); mesh.rotation.fromArray(d.rot); mesh.scale.fromArray(d.scale);
                mesh.castShadow = mesh.receiveShadow = true; scene.add(mesh);
            });
            transformControls.detach();
            updateGUI();
        }

        // --- 3. È†ÇÁÇπ„ÉªÈù¢ Á∑®ÈõÜ„É≠„Ç∏„ÉÉ„ÇØ ---
        function toggleVertexMode(v) {
            isVertexMode = v; if(v) { isFaceMode = false; guiParams.faceMode = false; faceMarkers.clear(); createVertexMarkers(); }
            else vertexMarkers.clear();
        }

        function createVertexMarkers() {
            vertexMarkers.clear(); if (!currentMesh) return;
            const pos = currentMesh.geometry.attributes.position.array;
            const map = new Map();
            for (let i = 0; i < pos.length; i += 3) {
                const v = new THREE.Vector3(pos[i], pos[i+1], pos[i+2]).applyMatrix4(currentMesh.matrixWorld);
                const key = v.toArray().map(n => n.toFixed(3)).join(',');
                if (!map.has(key)) {
                    const m = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshBasicMaterial({color: 0xff0000}));
                    m.position.copy(v); m.userData = { isMarker: true, indices: [i] };
                    vertexMarkers.add(m); map.set(key, m);
                } else map.get(key).userData.indices.push(i);
            }
        }

        function createFaceMarkers() {
            faceMarkers.clear(); if (!currentMesh) return;
            const pos = currentMesh.geometry.attributes.position.array;
            for (let i = 0; i < pos.length; i += 9) {
                const v1 = new THREE.Vector3(pos[i], pos[i+1], pos[i+2]);
                const v2 = new THREE.Vector3(pos[i+3], pos[i+4], pos[i+5]);
                const v3 = new THREE.Vector3(pos[i+6], pos[i+7], pos[i+8]);
                const center = new THREE.Vector3().add(v1).add(v2).add(v3).divideScalar(3).applyMatrix4(currentMesh.matrixWorld);
                const m = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshBasicMaterial({color: 0x00ffff}));
                m.position.copy(center); m.userData = { isMarker: true, faceIdx: i/9 };
                faceMarkers.add(m);
            }
        }

        function extrudeFace() {
            if (!currentMesh || selectedFaceIndex === -1) return;
            saveState();
            const pos = currentMesh.geometry.attributes.position.array; const idx = selectedFaceIndex * 9;
            const v1 = new THREE.Vector3(pos[idx], pos[idx+1], pos[idx+2]);
            const v2 = new THREE.Vector3(pos[idx+3], pos[idx+4], pos[idx+5]);
            const v3 = new THREE.Vector3(pos[idx+6], pos[idx+7], pos[idx+8]);
            const normal = new THREE.Vector3().crossVectors(v2.clone().sub(v1), v3.clone().sub(v1)).normalize();
            const offset = normal.multiplyScalar(0.5);
            const nv1 = v1.clone().add(offset), nv2 = v2.clone().add(offset), nv3 = v3.clone().add(offset);
            const newVerts = Array.from(pos);
            newVerts[idx] = nv1.x; newVerts[idx+1] = nv1.y; newVerts[idx+2] = nv1.z;
            newVerts[idx+3] = nv2.x; newVerts[idx+4] = nv2.y; newVerts[idx+5] = nv2.z;
            newVerts[idx+6] = nv3.x; newVerts[idx+7] = nv3.y; newVerts[idx+8] = nv3.z;
            const addS = (a, b, na, nb) => {
                newVerts.push(a.x,a.y,a.z, b.x,b.y,b.z, na.x,na.y,na.z);
                newVerts.push(b.x,b.y,b.z, nb.x,nb.y,nb.z, na.x,na.y,na.z);
            };
            addS(v1, v2, nv1, nv2); addS(v2, v3, nv2, nv3); addS(v3, v1, nv3, nv1);
            updateMeshGeo(newVerts);
        }

        function insetFace() {
            if (!currentMesh || selectedFaceIndex === -1) return;
            saveState();
            const pos = currentMesh.geometry.attributes.position.array; const idx = selectedFaceIndex * 9;
            const v1 = new THREE.Vector3(pos[idx], pos[idx+1], pos[idx+2]);
            const v2 = new THREE.Vector3(pos[idx+3], pos[idx+4], pos[idx+5]);
            const v3 = new THREE.Vector3(pos[idx+6], pos[idx+7], pos[idx+8]);
            const center = new THREE.Vector3().add(v1).add(v2).add(v3).divideScalar(3);
            const nv1 = v1.clone().lerp(center, 0.3), nv2 = v2.clone().lerp(center, 0.3), nv3 = v3.clone().lerp(center, 0.3);
            const newVerts = Array.from(pos);
            newVerts[idx]=nv1.x; newVerts[idx+1]=nv1.y; newVerts[idx+2]=nv1.z;
            newVerts[idx+3]=nv2.x; newVerts[idx+4]=nv2.y; newVerts[idx+5]=nv2.z;
            newVerts[idx+6]=nv3.x; newVerts[idx+7]=nv3.y; newVerts[idx+8]=nv3.z;
            const addS = (a, b, na, nb) => {
                newVerts.push(a.x,a.y,a.z, b.x,b.y,b.z, na.x,na.y,na.z);
                newVerts.push(b.x,b.y,b.z, nb.x,nb.y,nb.z, na.x,na.y,na.z);
            };
            addS(v1, v2, nv1, nv2); addS(v2, v3, nv2, nv3); addS(v3, v1, nv3, nv1);
            updateMeshGeo(newVerts);
        }

        function updateMeshGeo(verts) {
            currentMesh.geometry.dispose(); currentMesh.geometry = new THREE.BufferGeometry();
            currentMesh.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verts), 3));
            currentMesh.geometry.computeVertexNormals(); createFaceMarkers(); saveState();
        }

        // --- 4. GUI Ë®≠ÂÆö ---
        const gui = new dat.GUI();
        const guiParams = {
            vertexMode: false, faceMode: false,
            color: '#0077ff', wireframe: false,
            showShadows: true, lightIntensity: 0.7,
            scaleX: 1, scaleY: 1, scaleZ: 1,
            extrude: () => extrudeFace(), inset: () => insetFace(),
            duplicate: () => { if(currentMesh){ const c = currentMesh.clone(); c.position.x+=1; scene.add(c); saveState(); }},
            delete: () => { if(currentMesh){ scene.remove(currentMesh); transformControls.detach(); currentMesh=null; saveState(); }},
            screenshot: () => { const a = document.createElement('a'); a.download='model.png'; a.href=renderer.domElement.toDataURL(); a.click(); },
            export: () => document.getElementById('exportModal').style.display='block'
        };

        const modeF = gui.addFolder('üõ† „É¢„Éº„ÉâÂàáÊõø');
        modeF.add(guiParams, 'vertexMode').name('È†ÇÁÇπÁ∑®ÈõÜ (V)').onChange(toggleVertexMode).listen();
        modeF.add(guiParams, 'faceMode').name('Èù¢Á∑®ÈõÜ (F)').onChange(v => { isFaceMode=v; if(v){ isVertexMode=false; guiParams.vertexMode=false; vertexMarkers.clear(); createFaceMarkers();} else faceMarkers.clear(); }).listen();
        modeF.open();

        const propF = gui.addFolder('üé® „Éó„É≠„Éë„ÉÜ„Ç£');
        propF.addColor(guiParams, 'color').name('Ëâ≤').onChange(v => { if(currentMesh) currentMesh.material.color.set(v); });
        propF.add(guiParams, 'wireframe').name('Á∑öÊû†Ë°®Á§∫').onChange(v => { if(currentMesh) currentMesh.material.wireframe = v; });
        propF.add(guiParams, 'scaleX', 0.1, 5).onChange(v => { if(currentMesh) currentMesh.scale.x = v; }).listen();
        propF.add(guiParams, 'scaleY', 0.1, 5).onChange(v => { if(currentMesh) currentMesh.scale.y = v; }).listen();
        propF.add(guiParams, 'scaleZ', 0.1, 5).onChange(v => { if(currentMesh) currentMesh.scale.z = v; }).listen();
        propF.open();

        // üëÅ Ë¶ñË¶öÂäπÊûú„Éï„Ç©„É´„ÉÄÔºà„Åì„Åì„Å´ÂΩ±„ÇíÂæ©Ê¥ªÔºâ
        const viewF = gui.addFolder('üëÅ Ë¶ñË¶öÂäπÊûú');
        viewF.add(guiParams, 'showShadows').name('ÂΩ±„ÇíË°®Á§∫').onChange(v => {
            renderer.shadowMap.enabled = v;
            scene.traverse(obj => { if(obj.isMesh) obj.material.needsUpdate = true; }); // ÂΩ±„ÅÆÂÜçË®àÁÆó„Çí‰øÉ„Åô
        });
        viewF.add(guiParams, 'lightIntensity', 0, 2).name('„É©„Ç§„Éà„ÅÆÂº∑„Åï').onChange(v => { dirLight.intensity = v; });
        viewF.open();

        const toolF = gui.addFolder('üöÄ „ÉÑ„Éº„É´');
        toolF.add(guiParams, 'extrude').name('Êäº„ÅóÂá∫„Åó');
        toolF.add(guiParams, 'inset').name('„Ç§„É≥„Çª„ÉÉ„Éà');
        toolF.add(guiParams, 'duplicate').name('Ë§áË£Ω (Ctrl+D)');
        toolF.add(guiParams, 'delete').name('ÂâäÈô§ (Del)');
        toolF.add(guiParams, 'screenshot').name('ÁîªÂÉè‰øùÂ≠ò');
        toolF.add(guiParams, 'export').name('„Ç®„ÇØ„Çπ„Éù„Éº„Éà');

        function updateGUI() {
            if(!currentMesh) return;
            guiParams.color = '#' + currentMesh.material.color.getHexString();
            guiParams.scaleX = currentMesh.scale.x; guiParams.scaleY = currentMesh.scale.y; guiParams.scaleZ = currentMesh.scale.z;
            gui.updateDisplay();
        }

        // --- 5. „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('pointerdown', e => {
            if (transformControls.dragging) return;
            mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
            raycaster.setFromCamera(mouse, camera);
            if(isVertexMode) {
                const hits = raycaster.intersectObjects(vertexMarkers.children);
                if(hits.length>0) transformControls.attach(hits[0].object);
            } else if(isFaceMode) {
                const hits = raycaster.intersectObjects(faceMarkers.children);
                if(hits.length>0) {
                    selectedFaceIndex = hits[0].object.userData.faceIdx;
                    if(faceHighlighter) scene.remove(faceHighlighter);
                    const pos = currentMesh.geometry.attributes.position.array; const i = selectedFaceIndex*9;
                    const geo = new THREE.BufferGeometry();
                    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([pos[i],pos[i+1],pos[i+2], pos[i+3],pos[i+4],pos[i+5], pos[i+6],pos[i+7],pos[i+8]]),3));
                    faceHighlighter = new THREE.Mesh(geo, highlightMat); faceHighlighter.applyMatrix4(currentMesh.matrixWorld);
                    faceHighlighter.name = "Highlighter"; scene.add(faceHighlighter);
                }
            } else {
                const hits = raycaster.intersectObjects(scene.children.filter(o => o.isMesh && !o.userData.isMarker && o !== floor));
                if(hits.length>0) { currentMesh = hits[0].object; transformControls.attach(currentMesh); updateGUI(); }
            }
        });

        transformControls.addEventListener('objectChange', () => {
            if(isVertexMode && currentMesh) {
                const pos = currentMesh.geometry.attributes.position;
                const inv = new THREE.Matrix4().copy(currentMesh.matrixWorld).invert();
                vertexMarkers.children.forEach(m => {
                    const local = m.position.clone().applyMatrix4(inv);
                    m.userData.indices.forEach(idx => pos.setXYZ(idx/3, local.x, local.y, local.z));
                });
                pos.needsUpdate = true; currentMesh.geometry.computeVertexNormals();
            }
        });

        window.addEventListener('keydown', e => {
            if(e.key.toLowerCase()==='v') { guiParams.vertexMode=!guiParams.vertexMode; toggleVertexMode(guiParams.vertexMode); }
            if(e.key.toLowerCase()==='f') { isFaceMode=!isFaceMode; guiParams.faceMode=isFaceMode; }
            if(e.key==='Delete') guiParams.delete();
            if(e.ctrlKey && e.key==='d') { e.preventDefault(); guiParams.duplicate(); }
            if(e.ctrlKey && e.key==='z') { if(history.index>0) applyState(history.stack[--history.index]); }
        });

        document.getElementById('doExport').onclick = () => {
            const fmt = document.getElementById('exportFormat').value;
            if(fmt==='json') { const b=new Blob([history.stack[history.index]],{type:'text/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='scene.json'; a.click(); }
            else if(fmt==='obj') { const s=new THREE.OBJExporter().parse(scene); const b=new Blob([s],{type:'text/plain'}); const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='model.obj'; a.click(); }
            document.getElementById('exportModal').style.display='none';
        };

        function addMesh(type) {
            let geo;
            if(type==='box') geo = new THREE.BoxGeometry(1,1,1);
            else if(type==='sphere') geo = new THREE.SphereGeometry(0.7,16,16);
            else if(type==='cylinder') geo = new THREE.CylinderGeometry(0.5,0.5,1,16);
            else geo = new THREE.PlaneGeometry(2,2);
            const m = new THREE.Mesh(geo.toNonIndexed(), new THREE.MeshPhongMaterial({color: 0x0077ff}));
            m.castShadow = m.receiveShadow = true; m.position.y = (type==='plane')?0.01:0.5;
            scene.add(m); currentMesh=m; transformControls.attach(m); updateGUI(); saveState();
        }

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();
        if(localStorage.getItem('3d_modeler_save')) applyState(localStorage.getItem('3d_modeler_save'));
    </script>
</body>
</html>
